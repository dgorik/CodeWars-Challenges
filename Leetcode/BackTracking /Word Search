/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    let row_count = board.length
    let col_count = board[0].length
    let set = new Set()

    for(let i = 0; i < board.length; i++){
        for(let j = 0; j < board[i].length; j++){
            let char = board[i][j]
            if(word[0] == char){
                if(dfs(i,j,0)){
                    return true
                }
            }
        }
    }
    return false

    function dfs(x,y,k){
        if(x >= row_count || y >= col_count || x < 0 || y < 0 || word[k] != board[x][y]) return false
        if(k == word.length - 1) return true
        let letter = board[x][y]
        board[x][y] = "seen"
        let found = dfs(x+1, y, k + 1) ||
                        dfs(x-1, y, k + 1) ||
                        dfs(x, y+1, k + 1) ||
                        dfs(x, y-1, k + 1)
        board[x][y] = letter
        return found

    }
};

//The general idea here is to loop through the board
//When you find a character that is a first letter of the word, you enter the first dfs
//You copy the letter of the character as visited and keep checking all letters around it
    //dfs(x+1, y, k + 1)
    //dfs(x-1, y, k + 1)
    //dfs(x, y+1, k + 1)
    //dfs(x, y-1, k + 1)
//if any of these recursive calls return true, that means we have found a word
//after we explored all recursive calls starting from the first letter and not all of them are true, we have to mark the first letter back to "unvisited" to let other letters in the board use it 
